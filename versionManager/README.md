## Strategy Pattern
##### როდესაც გაქვს მაგალითად გზა დასაგეგმი და შეიძლება ხან მანქანისთვის გინდოდეს დაგეგმვა, ხან ველოსიპედისთვის, ხან ფეხისთვის:

გექნება კლასი navigator რომელსაც ექნება getRoute() ფუნქცია. ამ კალსს ექნება რომელიმე strategy გადაცემული, იმის მიხედვით რისთვის გვინდოდა დაგეგმვა.
ამ stategy-ს ექნება execute მეთოდი სპეციფიკური, რისთვისაც ვგეგმავთ.
getRoute მეთოდში პროსტა ამ executes გამოვიძახებთ და რომელი strategy-ც ჰქონდა დასეტილი იმის გამოიძახება.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/strategy)

[მაგალითი პროექტში:](version_manager.py)
VersionManager რომ გადაეცემა History კლასის ობიექტი ეგ არის strategy და execute ის მაგივრად მას აქვს record და recover ფუნქციები. ეს ყველაფერი History პროტოკოლში არის გაწერილი.



## Decorator Pattern
##### როდესაც გვინდა მიმდევრობით რამდენიმე კლასმა გააკეთოს რაღაც, ჯერ ერთმა, მერე მისთვის გადაცემულმა, მერე კიდე ამ გადაცემულში გადაცემულმა და ასე. ამ კლასების მიმდევრობას შევადგენთ ასე ვთქვათ და მერე ფუნქციის გამოძახებით ყველა კლასი მიმდევრობით შეასრულებს ამ ფუნქციას.

ამისთვის ვქმნით რაღაც დეკორატორ კლასს, რომელსაც გადაეცემა რაღაც inner ობიექტი, როდესაც ამ დეკორატორის რომელიმე ფუნქციას გამოიძახებენ ხოლმე, ამ გამოძახებაში გეწერება იმ inner ის იგივე მეთოდის გამოძახება.
ყველა კლასი, რომელიც გვინდა ასე ვთქვათ, რომ გადავაბათ ერთმანეთზე და მიმდევრობით შევასრულებინოთ საქმე, უნდა იყვნენ შვილები ზევით აღწერილ დეკორატორ კლასისა. და უნდა გადაიტვირთონ იმის მეთოდები, როდესაც თავის საქმეს გააკეთებს მეთოდში მშობლის იგივე მეთოდი უნდა გამოიძახოს და ის ვიცით, რომ გადაცემულის იგივე ფუნქციას გამოიძახებს.
რომლითაც გვინდა რომ გაჩერდეს და მეთი აღარ გააგრძელოს, იმას არ უნდა ჰქონდეს მშობლის გამოძახება. და მაგას ეძახიან კონკრეტულ კომპონენტს.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/decorator)

[მაგალითი პროექტში:](limited_history.py)
HistoryDecorator არის დეკორატორ კლასი, რომელსაც სხვა კონკრეტული დეკორატორები აექსთენდებენ(მაგ: HistoryWithLimit). ხოლო გამჩერებელი ანუ კონკრეტული კომპონენტი არის მაგალითად InfiniteHistory, რომელიც აღარ იძახებს მშობლისას.



## Null Object Pattern
##### იმისთვის რომ არ მოგვიწიოს წერა, თუ ნალია მაშინ ეს ქენი და თუარადა ესო ყოველ ჯერზე, შეგვიძლია კლასი შევქმნათ რომელიც იქნება დეფაულთად ხოლმე და აღარ მოგვიწევს იფის წერა

მაგალითად გვაქვს კლასი, და ამ კლასის ობიექტს გადავცემთ რამე კლასს და გვინდა, რომ თუ არაფერი გადავეცით მაშინ გამოძახებისას ერრორ არ ამოგვიგდოს.
მაშინ შევქმნით იგივე პროტოკოლის რაღაც NoExecute კლასს და მაგალIთად pass ეწერება ყველა ფუნქციაში. ეს კლასი იქნება დეფაულტ მნიშვნელობა და შემდგომში თუ არაფერი გადასცეს ამ კლასს არგუმენტად აღარ მოგვიწევს შემოწმება ნალი ხოარ იყო, რადგან არ იქნება ნალი ის დეფაულტ NoExecute იქნება და მისი ფუნქციის გამოძახება ერორს არ გამოიწვევს.

პ.ს შეიძლება უბრალოდ pass კიარ დავუწეროთ, არამედ რამე კონკრეტული რაც გვინდა რომ გააკეთოს null ობის შემთხვევაში.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/introduce-null-object?authuser=0)

[მაგალითი პროექტში:](version_manager.py)
მაგალითად გვაქვს NoReset კლასსი რომელიც Resettable პროტოკოლს ემორჩილება. Version კლასს რომ გადაეცემა Resettable ობიექტი დეფაულტ მნიშვნელობად მითითებულია NoReset კლასი და თუა რ გადასცეს რამე ერრორის მაგივრად უბრალოდ არაფერს გააკეთებს როდესაც მის reset ფუნქციას გამოიძახებს. 



## Adapter Pattern
##### ვიყენებთ იმისთვის , რომ რაიმე კლასი დავამორჩილოთ რაიმე ინტერფეის, ისე რომ არ მოგვიწიოს ამ კალსის შეცვლა.

შემოვიღებთ Adapter კლასს, რომელიც დაემორჩილება იმ ინტერფეისს, რომელსაც გვინდა, რომ ემორჩილებოდეს. ამ ადაპტერ კლასს ასევე უნდა გადაეცეს იმ კლასის ობიექტი, რომლის დამორჩილებაც გვინდოდა.
თითოეულ ფუნქციას შემდგომ შესაბამისად დავუკავშირებთ ნამდვილ კლასთან, როგორც გვენდომება.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/adapter)

[მაგალითი პროექტში:](awesome_history.py)
მაგალითად გვქონდა AwesomeHistory კლასი რომელსაც ჰქონდა save და load ფუნქციები. შემოვიღეთ მისი ადაპტერი AwesomeHistoryAdapter კლასი რომელსაც არგუმენტად კონსტრუკტორში გადავეცით AwesomeHistory კლასის ობიექტი.
ეს Adapter კლასი დავამორჩილეთ სასურველ პროტოკოლს და შემდეგ შესაბამისად თითოეულ ფუნქციაში შესაბამისი ფუნქცია გამოვიძახეთ AwesomeHistory კლასის.




## Fluent Interface 
##### გადაბმულად რომ ვწეროთ ერთ ხაზად ფუნქციების მიმდევრობა, უბრალოდ ზოგს ეს სტილი მოსწონს და იყენებს

თითოეული ფუნქცია აბრუნებს თავისი თავის ობიექტს და შეგიძლია მიმდევრობით დაწერო ფუნქციები. x.make().do().drive()

[დეტალურად იხილეთ საიტზე](https://www.martinfowler.com/bliki/FluentInterface.html)

[მაგალითი პროექტში:](version_manager.py)
VersionManager კლასის შემდეგი ფუნქციები major, minor, patch, rollback აბრუნებენ თავიანთ ობიექტს, ამიტომ შესაძლებელია ასე გამოვიყენოთ ისინი: manager.major().minor().major().patch().major().rollback()

