## Chain Of Responsibility
##### თუ გვიწევს ჩამოვწეროთ, თუ ესაა მაშინ ეს გავაკეთოთ, თუ ეს მაშინ ეს და ასე შემდეგ და ცუდად გვქონდეს ჩამოწერილი იფები, აჯობებს მოვიქცეთ შემდეგნაირად:

ცალცალკე შევქმნით ყველა კლასს განსხვავებული ფუნქციონალისთვის იფში რაც უნდა ჩაგვეწერა. ამ კლასებს გადავაბამთ ერთმანეთს, და თითოეულ კლასს ექნება ფუნქცია, რომელშიც შეამოწმებს იფით თუ თავისი საქმეა გააკეთებს, თუარადა მის შემდეგს following-ის ფუნქციას გამოიძახებს, მერე ისიც შეამოწმებს თუ თავის საქმეა და ასე.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/chain-of-responsibility)

[მაგალითი პროექტში:](interpreter.py)
Move, Increment, Decrement, Jump ებს გადააბავენ ერთმანეთს, ანუ თითოეულს კონსტრუქტორში გადასცემენ შემდეგს ასეთ სტილში: Move(Jump(Increment())). და თითოეულის execute ფუნქციაში იფით შევამოწმებთ თუ მაგის საქმეა ანუ თუ შესაბამისი ინსტრუქციაა გადმოცემული მაშინ გააკეთებს, თუარადა შემდეგს გამოიძახებს.



## Iterator Pattern
##### რაიმე ქოლექშენი რომ გვქონდეს ან მსგავსი, მაგალითად გრაფი და მასზე შემოვლა რომ გვინდოდეს, შეიძლება dfs ითაც შემოგვევლო ან bfs. ამიტომ იტერატორ პატერნს ხმარობენ.

ორი ფუნქციაა რაც იტერატორს უნდა ჰქონდეს: hasNext() და getNext(). და რომ დაგვჭირდეს ხან ვთქვათ bfs ხან dfs შემოვლა ცალცალკე დავუწერთ ამ იტერატორს და შესაბამის გამოვიყენებთ.

პ.ს ძირითადად ენებში ჩაშენებულიას სტილში ამ პატერნის ამწყობი მექანიზმი და ვნახავთ როგორც შემდგომში.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/iterator)

[მაგალითი პროექტში:](program.py)
Program კლასი წარმოადგენს იტერატორ კლასის მაგალითს. python ში მის შესაქმელად __iter__ და __next__ მეთოდები საკმარისია.
__iter__ ში უბრალოდ დარესეტება ხდება, ხოლო __next__ ში თუ არის შემდეგი მისი დაბრუნება, თუარადა შესაბამისი ექსეპშენის.
მაგალითი თუ როგორ გამოიყენება შემდგომ შეგვიძლია ვნახოთ [Assembler](assembler.py) -ის კლასის run მეთოდში 



## Factory Method
##### ვთქვათ გვინდა, რომ ასეთი ფუნქცია დავწეროთ, რომ ამოვარდება ხოლმე დაიალოგ ფანჯარა და ამ ფანჯარაში გვინდა ბათონი იყოს. და რამდენიმე სტილის ბათონი რომ დაგვჭირდეს როგორ ვქნათ მაგას ვნახავთ:

შევქმნით კლასს რომელიც იქნება Creator. ამ კლასს ექნება ორი ფუნქცია, ერთი კაკრას დაიალოგ ფანჯარის დახატვის და მეორე ბათOნის შექმნის რომელიც იქნება აბსტრაქტული მეთოდი.
ფანჯარის დახატვის ფუნქციაში გამოიძახებს ბათონის შექმნის ფუნქციას და როგორ ბათონსაც დაუბრუნებს იმას გამოიტანს. ახლა ეს კლასი რომ ორმა სხვადასხვა კლასმა დაააექსთენდოს და ერთმა ეს abstract ფუნქციის ოვერრაიდი ისე გააკეთოს, რომ ვინდოუსის სტილის ღილაკი დახატოს და მეორემ კიდე ვების სტილის, ყველა დანარჩენი ფუნქციის თავიდან გადაწერა აღარ მოუწევთ და მარტო აბსტრაქტ მეთოდის ოვერრაიდი ეყოფათ.

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/factory-method)

[მაგალითი პროექტში:](assembler.py)
Assembler კლასი არის კაკრას Creator კლასის მაგალითი. create_interpreter() მეთოდი კაკრას აბსტრაქტულია. Run მეთოდში კი ხდება ამ მეთოდის გამოყენება.
AAAssembler კლასი კი არის ერთ-ერთი კონკრეტული კრეატორი, რომელსაც create_interpreter მეთოდი აქვს გადატვირთული და კონკრეტულ ინტერპრეტერს აბრუნებს.

