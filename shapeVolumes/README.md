## Composite Pattern
##### ვთქვათ გვინდა ყუთის ფასის დადგენა, რომელშიც რაღაცები ალაგია და თითოეულს კიდე ცალკე ფასი აქვს. და ასევე მსგავსი ყუთი შეიძლება იდოს ამ ყუთში და ასე.

შემოვიღOთ რამე ინტერფეისი, რომელსაც ექნება getPrice() ფუნქცია. უნდა შემოვიღოთ კლასი, რომელსაც ეძახიან Composite კლასს, რომელიც იგივე პროტოკოლს დაემორჩილება და ეს იქნება ასე ვთქვათ ანალოგი იმ ყუთის.
ამ კლასს კონსტრუქტორშიგ ადაეცემა ლისტი ასე ვთქვათ მასში ნივთების. ეს ნივთები არიან სხვადასხვა კლასის ობიექტები, მაგრამ ყველა კლასი ზევით შექმნილ პროტოკოლს ემორჩილება.
getPrice() ფუნქციაში პროსტა ეწერება გადაყოლა ფორით ყველა შვილზე ყველასთვის getPrice()-ს გამოძახება და აჯამვა. 

[დეტალურად იხილეთ საიტზე](https://refactoring.guru/design-patterns/composite)

[მაგალითი პროექტში:](volume.py)
ჩვენ შემთხვევაში, Shape არის პროტოკოლი, რომელსაც აქვს getVolume() ფუნქცია. გვაქვს კიდე Sphere და RectangularPrism კლასები რომლებიც იგივე პროტოკოლს ემორჩილებიან და შესაბამის მოცულობას აბრუნებენ.
გამაერთიანებელი კლასი კი ანუ Composite არის CombineShape კლასი, რომელსაც გადაეცემა Shape ების ლისტი. თითონ ეს კლასიც შეიფია და ამიტომ შეიძლება ამ ლისტში თავისი ტიპის ობიექტიც იყოს(ანუ ყუთში ყუთის მაგალითია ეს რა).



## Terminal -დან შეყვანა
##### ვთქვათ გვინდა რაიმე მნიშვნელობის შეტანა და გამოტანა ტერმინალზე, ეს რომ გატესტვადი იყოს, ვიქცევით ასე: 

შევქმნით პროტოკოლს და ორ კლასს(იმ პროტოკოლზე დამმორჩლებლებს) , რომელიც ერთი მართლა ტერმინალიდან წაიკითხავს და გამოიტანს ხოლმე ინფორმაციას, მეორე კი fake იქნება და უბრალოდ კონკრეტულ მნიშვნელობებს დაგვიბრუნებს ხოლმე, ვითომ ეგ წაიკითხა.
ამ კლასის ობიექტს გადავცემთ იმ ფუნქციას, სადაც უნდა დამუშავდეს ტერმინალიდან წაკითხული ინფორმაცია. თუ ტესტებისთვის გვენდომება იმ ფექის გადავცემთ, თუ პროდაქშენისთვის - ნამდვილს.

[მაგალითი პროექტში:](volume.py)
Console არის პროტოკოლი. TestConsole კონკრეტულ მნიშვნელობებს აბრუნებს და გასატესტად გამოიყენება, ხოლო RealConsole ნამდვილად ტერმინალიდან კითხულობს. get_volume() ფუნქციას გადაეცემა ამ კონსოლის ტიპის ობიექტი.
